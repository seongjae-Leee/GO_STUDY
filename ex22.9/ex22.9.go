/*
맵, 배열, 리스트 속도 비교(Big-O Notation)

			배열, 슬라이스			리스트			 맵
추가			O(N)						O(1)			  O(1)
삭제			O(N)						O(1)			  O(1)
읽기			O(1)인덱스로    O(N)인덱스로 O(1) 키로 접근(맵이 제일 빠른 대신 순회시 순서 보장이 안 된다. 그리고 공간적으로 메모리를 더 쓴다.)

*/
/*
	● 맵의 원리
해쉬 함수 동작 이해.. 1)같은 입력이 들어오면 같은 결과가 나온다. 2) 다른 입력이 들어가면 되도록 다른 결과가 나온다. 3) 입력값 범위는 무한대이고 결과는 특정 범위를 가진다.
나머지 연산(%)에서 같은 입력을 하면 같은 결과를 보여준다.
해쉬란 잘게 부순다는 뜻이다

*/

package main

import (
	"fmt"
)

const M = 10 // 사실상 배열의 길이를 정의해준 것

func hash(d int) int {
	return d % M
}

func main() {
	m := [M]string{}    // 값(타입도 지정)을 넣을 배열을 정의해주고
	m[hash(23)] = "송하나" // 키23 에 해당하는 값 송하나를 넣어줌.
	m[hash(259)] = "백두산"

	fmt.Printf("%d = %s\n", 23, m[hash(23)])
	fmt.Printf("%d = %s\n", 259, m[hash(259)])
	fmt.Printf("%d = %s\n", 113, m[hash(113)])
}

/*
결과값 :
23 = 송하나
259 = 백두산
113 = 송하나
*/
// 모듈라(%)는 상수 연산, O(1)이기 때문에 출력이 굉장히 빠르다.
